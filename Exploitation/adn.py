import random
import os
import numpy as np
nucleotides=['A','T','G','C']
def generer_adn(nom_fichier : str, longueur : int):
    chemin = os.path.join(os.getcwd(), f"{nom_fichier}.adn")
    nom_final=""
    res = ""
    if os.path.exists(chemin):
        rep = input("Le fichier existe déjà, voulez vous l'écraser ? (o/n): ")
        if rep.lower() == "o":
            for _ in range(longueur):
                res += random.choice(nucleotides)
            nom_final = nom_fichier
        else:
            while rep.lower() != "esc" and os.path.exists(chemin):
                rep = input("Veuillez entrer le nouveau nom de votre fichier ou 'esc' pour annuler: ")
                chemin = os.path.join(os.getcwd(), f"{rep}.adn")
                if not os.path.exists(chemin):
                    for _ in range(longueur):
                        res += random.choice(nucleotides)
                    nom_final = rep
                    break
                else:
                    print(f"Le fichier '{rep}.adn' existe déjà.")
    else:
        for _ in range(longueur):
            res += random.choice(nucleotides)
        nom_final = nom_fichier

    adn_formate = ""
    largeur_ligne = 80
    for i in range(0, len(res), largeur_ligne):
        adn_formate += res[i:i+largeur_ligne] 
    
    with open(f"{nom_final}.adn", "w", encoding="utf8") as f:
        f.write(adn_formate)
    print(f"Fichier '{nom_final}.adn' créé avec succès!")
    
def muter_adn_remplacement(nom_fichier, proba_mutation, sortie=True):
    """
    Applique des remplacement de nucléotides aléatoires à une séquence ADN avec probabilité p.
    
    Args:
        nom_fichier: fichier ADN d'entrée
        proba_mutation: probabilité de mutation pour chaque nucléotide (0.0 à 1.0)
    Returns:
        nom_fichier_sortie
    """
    if not nom_fichier.endswith('.adn'):
        nom_fichier += '.adn'
    if sortie:
        nom_fichier_sortie = nom_fichier.replace('.adn', f'_remplacement_{int(proba_mutation*100)}.adn')
    elif sortie is not True:
        nom_fichier_sortie = f"{nom_fichier}+_mute.adn"
    sequence_mutee = ""
    mutations_count = 0
    with open(nom_fichier, 'r', encoding='utf8') as f:
        for ligne in f:
            ligne = ligne.strip()
            ligne_mutee = ""
            for nucleotide in ligne:
                if nucleotide in nucleotides:
                    if random.random() < proba_mutation:
                        nouveaux_nucleotides = [n for n in nucleotides if n != nucleotide]
                        nucleotide_mute = random.choice(nouveaux_nucleotides)
                        ligne_mutee += nucleotide_mute
                        mutations_count += 1
                    else:
                        ligne_mutee += nucleotide
                else:
                    ligne_mutee += nucleotide
            sequence_mutee += ligne_mutee 
    
    with open(nom_fichier_sortie, 'w', encoding='utf8') as f:
        f.write(sequence_mutee)
    print(f"{mutations_count} remplacements terminés !")
    return nom_fichier_sortie

def muter_adn_deletion(nom_fichier, proba_mutation, sortie=True):
    """
    Applique des deletions aléatoires à une séquence ADN avec probabilité p.
    
    Args:
        nom_fichier: fichier ADN d'entrée
        proba_mutation: probabilité de mutation pour chaque nucléotide (0.0 à 1.0)
    Returns:
        nom_fichier_sortie
    """
    if not nom_fichier.endswith('.adn'):
        nom_fichier += '.adn'
    if sortie:
        nom_fichier_sortie = nom_fichier.replace('.adn', f'_deletion_{int(proba_mutation*100)}.adn')
    elif sortie is not True:
        nom_fichier_sortie = f"{nom_fichier}+_mute.adn"
    sequence_mutee = ""
    mutations_count = 0
    with open(nom_fichier, 'r', encoding='utf8') as f:
        for ligne in f:
            ligne = ligne.strip()
            ligne_mutee = ""
            for nucleotide in ligne:
                if nucleotide in nucleotides:
                    if random.random() < proba_mutation:
                        mutations_count += 1
                    else:
                        ligne_mutee += nucleotide
                else:
                    ligne_mutee += nucleotide
            sequence_mutee += ligne_mutee 
    with open(nom_fichier_sortie, 'w', encoding='utf8') as f:
        f.write(sequence_mutee)
    print(f"{mutations_count} deletions terminées !")
    return nom_fichier_sortie

def muter_adn_insertion(nom_fichier, proba_mutation, sortie= True):
    """
    Applique des insertions aléatoires à une séquence ADN avec probabilité p.
    
    Args:
        nom_fichier: fichier ADN d'entrée
        proba_mutation: probabilité de mutation pour chaque nucléotide (0.0 à 1.0)
    Returns:
        nom_fichier_sortie
    """
    if not nom_fichier.endswith('.adn'):
        nom_fichier += '.adn'
    if sortie:
        nom_fichier_sortie = nom_fichier.replace('.adn', f'_insertion_{int(proba_mutation*100)}.adn')
    elif sortie is not True:
        nom_fichier_sortie = f"{nom_fichier}+_mute.adn"
    sequence_mutee = ""
    nb_insert = 0
    with open(nom_fichier, 'r', encoding='utf8') as f:
        for ligne in f:
            ligne = ligne.strip()
            ligne_mutee = ""
            for nucleotide in ligne:
                if random.random() < proba_mutation:
                    nucleotide_mute = random.choice(nucleotides)
                    ligne_mutee += nucleotide_mute
                    nb_insert += 1
                ligne_mutee += nucleotide
            sequence_mutee += ligne_mutee
    with open(nom_fichier_sortie, 'w', encoding='utf8') as f:
        f.write(sequence_mutee)
    print(f"{nb_insert} insertions terminées !")
    return nom_fichier_sortie


def mutations(nom_fichier, proba_r, proba_d, proba_i):
    """
    Permet d'appliquer une ou plusieurs mutations sur un fichier ADN.
    Les fichiers intermédiaires sont supprimés : seul le fichier final est conservé.
    Returns:
        chemin du fichier final produit (ou le fichier d'entrée si aucune mutation appliquée)
    """
    fichier_final=nom_fichier+"_mutation.adn"
    if not nom_fichier.endswith('.adn'):
        nom_fichier += '.adn'

    mutation = {
        'r': (muter_adn_remplacement, proba_r),
        'd': (muter_adn_deletion, proba_d),
        'i': (muter_adn_insertion, proba_i)
    }
    outputs = []
    current_input = nom_fichier

    for c in mutation.keys():
        func, p = mutation[c]
        if p <= 0:
            continue
        sortie = func(current_input, p, False)
        outputs.append(sortie)
        current_input = sortie

    # supprimer les fichiers intermédiaires (tout sauf le dernier)
    if len(outputs) > 1:
        for path in outputs[:-1]:
            try:
                if os.path.exists(path):
                    os.remove(path)
            except OSError:
                pass

    if outputs:
        final = outputs[-1]
        nv_path=os.rename(final, f"{nom_fichier}_mutations.adn")
        print(f"Traitement terminé. Fichier final : {nom_fichier}_mutations.adn")
    else:
        print("Aucune mutation appliquée.")
        return nom_fichier
    
def distance_remplacement(adn, adn_bis):
    assert(len(adn)==len(adn_bis)), "les fichiers n'ont pas été changé par mutation uniquement"
    distance = 0
    for i in range(len(adn)):
        if adn[i]!=adn_bis[i]:
            distance+=1
    return distance

def distance_levenshtein(adn, adn_bis):
    x=len(adn)+1
    y=len(adn_bis)+1
    matrice=np.zeros((x,y))
    for i in range(x):
        matrice[i, 0]=i
    for j in range(y):
        matrice[0, j]=j
    for i in range(1,x):
        for j in range(1,y):
            if adn[i-1]==adn_bis[j-1]:
                cout_substitution=0
            else:
                cout_substitution=1
            matrice[i,j]=min(matrice[i-1,j]+1, matrice[i,j-1]+1, matrice[i-1,j-1]+cout_substitution)
    return matrice[x-1,y-1]

